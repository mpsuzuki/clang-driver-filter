# clang-driver-filter.sh
========================

## What is this?

This is a shell script that extracts the final command
that Apple Clang intends to execute, applies filters to it,
and then prints (or executes) the corrected command.
Currently, the script is designed for the linking phase,
so only the final linker invocation is processed.

Tested on MacOSX 10.15 (Catalina) + Apple Clang 12.

## Why?

Some versions of Apple Clang attempt to link the internal
component libraries of the *System framework* directly, which
fails. To avoid this incorrect behavior, this script filters
out any `-lsystem_xxx` options from the raw linker command
generated by the Clang driver.

### About System.framework and its internal structure

Historically, macOS shipped a single large `libSystem.dylib`.
Later, Apple split it into multiple internal components,
similar to the structure of a framework.

Current `System.framework` is an *umbrella framework*.
This means that it exposes a single public interface
(`-lSystem` or `-framework System`), while internally
it consists of multiple sub-libraries that are not
intended to be linked directly.

Examples of such internal components include:

- libsystem_c
- libsystem_m
- libsystem_malloc
- libsystem_pthread
- libsystem_coreservices
- ... (and others)

These sub-libraries are shipped only as `.tbd` stub files
and their actual implementations reside inside the
*dyld shared cache*. Because of this, they cannot be
linked directly by user code.

Only the umbrella library (`-lSystem`) should be linked.
The system linker resolves the appropriate internal
components automatically at runtime.

### The problem to be cared

However, certain versions of Apple Clang incorrectly
attempt to link these component libraries directly,
even when the user requests nothing. For example,
Clang may expand append to `-lsystem_pthread -lSystem`,
if the built library is designed to be placed under
`/usr/lib/system`, like `-install_name /usr/lib/system/xxx.dylib`,
even if the library has no dependency with PTHREAD.

Unfortunately, `libsystem_pthread.dylib` is not shipped
as a real dylib any longer. Apple removed the actual dylibs
and now provides only `.tbd` stubs, which cannot be linked
directly.

In practice, users should not link `-lsystem_xxx` manually.
Using `-lSystem` or `-framework System` is sufficient, and
the system linker resolves the appropriate components
internally.

## What this script does

The script runs `clang -###` to obtain the final linker
command, removes any `-lsystem_xxx` arguments, and outputs
the filtered command.

If Clang cannot reach the execution stage (e.g., due to
unknown options or missing object files), the script prints
the error messages and does not attempt to run anything.

If the compiler is not Apple Clang, no filtering is applied.

## How to use this

A typical Makefile rule might look like:
```
libXXX.dylib: obj1.o obj2.o obj3.o
	$(CC) $(CFLAGS) $(LDFLAGS) -dynamiclib -o $@ $^
```

To use this script, wrap the compiler invocation:
```
LINK_WRAP ?= /path/to/clang-driver-filter.sh

libXXX.dylib: obj1.o obj2.o obj3.o
	$(LINK_WRAP) $(CC) $(CFLAGS) $(LDFLAGS) -dynamiclib -o $@ $^
```

## Current scope and limitations

Currently, this script is intended for the final linking
stage only. It does not support cases where Clang
performs multiple actions in a single invocation, such as:

```
hello: hello.c
	$(CC) -o $@ $^
```

In such cases, `clang -###` prints multiple commands
(compile, assemble, link). Currently this script ignores
all but the final command, so it cannot be used for this
type of rule.
